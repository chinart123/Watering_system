Giai ƒëo·∫°n A: Thi·∫øt l·∫≠p h·ªá th·ªëng c∆° b·∫£n
M·ª•c ti√™u ch√≠nh:
X√¢y d·ª±ng n·ªÅn t·∫£ng ph·∫ßn c·ª©ng tr·ª´u t∆∞·ª£ng (HAL), thi·∫øt l·∫≠p c·∫•u tr√∫c d·ª± √°n v√† ƒë·∫£m b·∫£o h·ªá th·ªëng ho·∫°t ƒë·ªông c∆° b·∫£n tr√™n c·∫£ m√¥ ph·ªèng (VSCode) v√† ph·∫ßn c·ª©ng th·∫≠t (STM32).


1. M·ª•c ti√™u & Nhi·ªám v·ª•
Th√†nh ph·∫ßn	            Chi ti·∫øt
M·ª•c ti√™u	            - Thi·∫øt l·∫≠p HAL cho GPIO/Timer
                        - X√¢y d·ª±ng h·ªá th·ªëng ƒëa n·ªÅn t·∫£ng
                        - Ki·ªÉm th·ª≠ n·ªÅn t·∫£ng c∆° b·∫£n

Nhi·ªám v·ª•	            ‚ñ∂ T·∫°o c·∫•u tr√∫c th∆∞ m·ª•c c∆° b·∫£n
                        ‚ñ∂ Tri·ªÉn khai HAL layer:
                        - hal_gpio.h/c (GPIO abstraction)
                        - hal_time.h/c (Timer abstraction)
                        ‚ñ∂ Vi·∫øt driver cho t·ª´ng n·ªÅn t·∫£ng:
                        - Simulator: sim_gpio.c, sim_time.c
                        - STM32: stm32_gpio.c, stm32_time.c
                        ‚ñ∂ X√¢y d·ª±ng h√†m main ri√™ng cho m·ªói n·ªÅn t·∫£ng
Ti√™u ch√≠ th√†nh c√¥ng	    ‚úÖ Code HAL bi√™n d·ªãch kh√¥ng l·ªói
                        ‚úÖ Driver m√¥ ph·ªèng/ph·∫ßn c·ª©ng ho·∫°t ƒë·ªông ƒë·ªôc l·∫≠p
                        ‚úÖ Ki·ªÉm th·ª≠ GPIO/Timer th√†nh c√¥ng tr√™n c·∫£ 2 n·ªÅn t·∫£ng
**Note**Core\Inc\App v√† Core\Inc\App v·∫´n c·∫ßn thi·∫øt nh∆∞ng s·∫Ω ƒë∆∞·ª£c tri·ªÉn khai trong giai ƒëo·∫°n B (Logic ƒëi·ªÅu khi·ªÉn c·ªët l√µi), kh√¥ng ph·∫£i trong giai ƒëo·∫°n A.
D:\HOC_NHUNG\BAI_TAP\Buoi_4\Buoi_4_v2\Watering_System\
‚îú‚îÄ‚îÄ Core/
‚îÇ   ‚îú‚îÄ‚îÄ Inc/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ HAL/                   # Ch·ªâ HAL trong giai ƒëo·∫°n A
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ hal_gpio.h
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ hal_time.h
‚îÇ   ‚îî‚îÄ‚îÄ Src/
‚îÇ       ‚îî‚îÄ‚îÄ HAL/                   # Tri·ªÉn khai HAL chung
‚îÇ           ‚îú‚îÄ‚îÄ hal_gpio.c
‚îÇ           ‚îî‚îÄ‚îÄ hal_time.c
‚îú‚îÄ‚îÄ Platforms/
‚îÇ   ‚îú‚îÄ‚îÄ Simulator_VSCode/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Drivers/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sim_gpio.c         # Driver gi·∫£ l·∫≠p GPIO
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sim_time.c         # Driver gi·∫£ l·∫≠p Timer
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main_sim.c             # Main cho m√¥ ph·ªèng
‚îÇ   ‚îî‚îÄ‚îÄ STM32F103C8T6/
‚îÇ       ‚îú‚îÄ‚îÄ Drivers/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ stm32_gpio.c       # Driver GPIO th·∫≠t
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ stm32_time.c       # Driver Timer th·∫≠t
‚îÇ       ‚îú‚îÄ‚îÄ Project/               # CubeMX project
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Core/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ STM32.ioc
‚îÇ       ‚îî‚îÄ‚îÄ main.c                 # Main cho STM32
‚îî‚îÄ‚îÄ Docs/
    ‚îî‚îÄ‚îÄ hardware_map.md            # T√†i li·ªáu √°nh x·∫° ch√¢n


2. Logic chung cho VSCode & STM32
C·∫•u tr√∫c file ch√≠nh:
// Core/Inc/HAL/hal_gpio.h
#pragma once
typedef enum { GPIO_LOW, GPIO_HIGH } GPIO_State;
void HAL_GPIO_Write(uint8_t pin, GPIO_State state);
GPIO_State HAL_GPIO_Read(uint8_t pin);

// Core/Src/HAL/hal_gpio.c
#include "hal_gpio.h"
// G·ªçi h√†m driver t∆∞∆°ng ·ª©ng (tri·ªÉn khai ·ªü Platforms)
void HAL_GPIO_Write(uint8_t pin, GPIO_State state) {
    PLATFORM_GPIO_Write(pin, state); // Platform-specific implementation
}                        


Quy t·∫Øc ph√°t tri·ªÉn:
+ Platform-Independent Code: To√†n b·ªô logic trong Core/ kh√¥ng tham chi·∫øu tr·ª±c ti·∫øp ƒë·∫øn ph·∫ßn c·ª©ng
+ H√†m callback: ƒê·ªãnh nghƒ©a h√†m platform-specific trong HAL (vd: PLATFORM_GPIO_Write())
+ Header Guard: S·ª≠ d·ª•ng #pragma once trong t·∫•t c·∫£ header files

3. M√¥ ph·ªèng tr√™n VSCode
M·ª•c ti√™u ki·ªÉm th·ª≠:
+ GPIO gi·∫£ l·∫≠p: Xu·∫•t console log khi ghi/ƒë·ªçc
+ Timer gi·∫£ l·∫≠p: ƒêo th·ªùi gian ch√≠nh x√°c ¬±5ms
+ Ch∆∞∆°ng tr√¨nh ch·∫°y li√™n t·ª•c kh√¥ng crash

B√†i test m·∫´u:
// Platforms/Simulator_VSCode/main_sim.c
#include "hal_gpio.h"
#include "hal_time.h"

int main() {
    HAL_GPIO_Write(LED_PIN, GPIO_HIGH);
    printf("[SIM] LED ON\n");
    
    HAL_Delay(1000); // Delay 1s
    
    if (HAL_GPIO_Read(BUTTON_PIN) == GPIO_HIGH) {
        printf("[SIM] Button pressed!\n");
    }
}

K·ªãch b·∫£n test:
1. GPIO Write Test: Ki·ªÉm tra console xu·∫•t hi·ªán [SIM] LED ON
2. Delay Test: ƒê·∫£m b·∫£o delay gi·ªØa 995-1005ms
3. GPIO Read Test: Nh·∫≠p gi√° tr·ªã gi·∫£ l·∫≠p t·ª´ b√†n ph√≠m ‚Üí ki·ªÉm tra console log

4. Tri·ªÉn khai tr√™n STM32
M·ª•c ti√™u ki·ªÉm th·ª≠:
+ LED v·∫≠t l√Ω nh·∫•p nh√°y chu k·ª≥ 1s
+ Nh·∫•n n√∫t ‚Üí ƒë·ªçc ƒë√∫ng tr·∫°ng th√°i
+ Kh√¥ng c√≥ l·ªói runtime (hardfault, stack overflow)
B√†i test m·∫´u:
// Platforms/STM32F103C8T6/main.c
#include "stm32f1xx_hal.h"
#include "hal_gpio.h"

#define LED_PIN    GPIO_PIN_13
#define BUTTON_PIN GPIO_PIN_0

int main(void) {
    HAL_Init();
    __HAL_RCC_GPIOC_CLK_ENABLE();
    
    while (1) {
        HAL_GPIO_Write(LED_PIN, GPIO_HIGH);
        HAL_Delay(500);
        HAL_GPIO_Write(LED_PIN, GPIO_LOW);
        HAL_Delay(500);
        
        if (HAL_GPIO_Read(BUTTON_PIN) == GPIO_HIGH) {
            // X·ª≠ l√Ω nh·∫•n n√∫t
        }
    }
}

K·ªãch b·∫£n test:
1. LED Blink Test: D√πng ƒë·ªìng h·ªì ƒëo chu k·ª≥ s√°ng/t·∫Øt LED
2. Button Test:
+ Nh·∫•n n√∫t v·∫≠t l√Ω ‚Üí LED s√°ng ngay
+ Nh·∫£ n√∫t ‚Üí LED t·∫Øt
3. Stress Test: Ch·∫°y li√™n t·ª•c 10 ph√∫t ‚Üí ki·ªÉm tra nhi·ªát ƒë·ªô chip

Checklist ho√†n th√†nh giai ƒëo·∫°n A
Ho√†n thi·ªán c·∫•u tr√∫c th∆∞ m·ª•c theo s∆° ƒë·ªì

HAL layer ƒë√≥ng g√≥i ƒë·ªß GPIO/Timer

Simulator: Pass 3/3 test case

STM32: LED nh·∫•p nh√°y ƒë√∫ng chu k·ª≥ ¬±20ms

T√†i li·ªáu hardware_map.md c·∫≠p nh·∫≠t ch√¢n GPIO th·∫≠t

üí° Tips th·ª±c hi·ªán:

∆Øu ti√™n ho√†n thi·ªán simulator tr∆∞·ªõc khi ƒë·ª•ng ph·∫ßn c·ª©ng

S·ª≠ d·ª•ng printf() debug tr√™n c·∫£ 2 n·ªÅn t·∫£ng

Commit code sau m·ªói th√†nh ph·∫ßn ho√†n thi·ªán (HAL ‚Üí Driver ‚Üí Test)
---------------------------------------------------------------------
A. SYSTEM STATES DEFINITION
// System Modes
typedef enum {
    MODE_AUTO,      // Automatic watering based on sensors
    MODE_MANUAL     // Manual control mode
} SystemMode;

// Pump States
typedef enum {
    PUMP_OFF,       // Pump inactive
    PUMP_ON         // Pump active
} PumpState;

// LED States
typedef enum {
    LED_NORMAL,             // Green: Normal operation
    LED_WATERING,           // Yellow: Watering in progress
    LED_LOW_MOISTURE_ALERT, // Red: Soil moisture below threshold
    LED_ERROR               // Blinking Red: System error
} LEDState;

B. CORE DATA STRUCTURES
// Sensor Data
typedef struct {
    volatile float soil_moisture;  // 0-100%
    volatile float temperature;    // ¬∞C
} SensorData;

// System Configuration
typedef struct {
    float moisture_min_th;     // Minimum moisture threshold
    float moisture_max_th;     // Maximum moisture threshold
    uint32_t max_watering_time;// Max watering duration (ms)
    uint32_t check_interval;   // Sensor check interval (ms)
} SystemConfig;

// System State
typedef struct {
    SystemMode current_mode;
    PumpState pump_state;
    LEDState led_state;
    SystemConfig config;
    SensorData sensor_readings;
    
    // Internal state tracking ?????????
    uint32_t last_sensor_check; //?????????????
    uint32_t pump_start_time; //?????????????
    bool manual_override; //?????????????
} SystemState;

Gi·∫£i th√≠ch v√† Ki·ªÉm th·ª≠ th·ª±c t·∫ø
1.Ki·ªÉm tra last_sensor_check: 
M·ª•c ƒë√≠ch:
-L∆∞u th·ªùi ƒëi·ªÉm (timestamp) cu·ªëi c√πng khi h·ªá th·ªëng ƒë·ªçc gi√° tr·ªã t·ª´ c·∫£m bi·∫øn DHT11.
-ƒê∆°n v·ªã: milliseconds (s·ª≠ d·ª•ng HAL_GetTick() c·ªßa HAL library).
C√°ch ho·∫°t ƒë·ªông v·ªõi STM32:
// Trong v√≤ng l·∫∑p ch√≠nh:
if (HAL_GetTick() - last_sensor_check > CHECK_INTERVAL) {
    read_DHT11(); // G·ª≠i t√≠n hi·ªáu START v√† ƒë·ªçc data t·ª´ DHT11
    last_sensor_check = HAL_GetTick(); // C·∫≠p nh·∫≠t th·ªùi ƒëi·ªÉm cu·ªëi c√πng
}
L∆∞u √Ω:
-DHT11 y√™u c·∫ßu kho·∫£ng th·ªùi gian t·ªëi thi·ªÉu 2 gi√¢y gi·ªØa c√°c l·∫ßn ƒë·ªçc.
-N√™n ƒë·∫∑t CHECK_INTERVAL = 2000 (ms) ƒë·ªÉ tr√°nh l·ªói c·∫£m bi·∫øn.
---->ƒê·∫∑t breakpoint t·∫°i read_DHT11(), x√°c nh·∫≠n h√†m ƒë∆∞·ª£c g·ªçi m·ªói 2 gi√¢y.
2. Ki·ªÉm tra pump_start_time: 
M·ª•c ƒë√≠ch:
- Ghi l·∫°i th·ªùi ƒëi·ªÉm b∆°m n∆∞·ªõc ƒë∆∞·ª£c b·∫≠t (d√πng ƒë·ªÉ t√≠nh th·ªùi gian b∆°m ƒë√£ ho·∫°t ƒë·ªông).
- NgƒÉn ch·∫∑n b∆°m ch·∫°y qu√° l√¢u (vd: qu√° 30 gi√¢y) d·∫´n ƒë·∫øn ng·∫≠p n∆∞·ªõc.

Tri·ªÉn khai tr√™n STM32:
void start_pump() {
    HAL_GPIO_WritePin(PUMP_GPIO_Port, PUMP_Pin, GPIO_PIN_SET); // B·∫≠t b∆°m
    pump_start_time = HAL_GetTick(); // Ghi l·∫°i th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu
}

void check_pump_timeout() {
    if (HAL_GetTick() - pump_start_time > MAX_PUMP_TIME) {
        HAL_GPIO_WritePin(PUMP_GPIO_Port, PUMP_Pin, GPIO_PIN_RESET); // T·∫Øt b∆°m
    }
}
Hardware Connection:
Ch√¢n ƒëi·ªÅu khi·ªÉn b∆°m n·ªëi qua transistor/MOSFET (vd: GPIO PA1).
---->B·∫≠t ch·∫ø ƒë·ªô debug, theo d√µi bi·∫øn n√†y khi nh·∫•n n√∫t t∆∞·ªõi th·ªß c√¥ng.
3. Ki·ªÉm tra manual_override:
M·ª•c ƒë√≠ch:
- C·ªù b√°o hi·ªáu h·ªá th·ªëng ƒëang b·ªã "ghi ƒë√®" b·ªüi ng∆∞·ªùi d√πng (t·∫Øt ch·∫ø ƒë·ªô t·ª± ƒë·ªông).
- Khi = true: H·ªá th·ªëng b·ªè qua logic t·ª± ƒë·ªông, ch·ªâ ph·∫£n h·ªìi n√∫t nh·∫•n.
V√≠ d·ª• v·ªõi n√∫t nh·∫•n STM32:
// X·ª≠ l√Ω ng·∫Øt n√∫t nh·∫•n (EXTI)
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
    if (GPIO_Pin == BUTTON_Pin) {
        manual_override = !manual_override; // ƒê·∫£o tr·∫°ng th√°i
    }
}
L∆∞u √Ω:
C·∫ßn debounce n√∫t nh·∫•n b·∫±ng ph·∫ßn c·ª©ng (t·ª• 100nF) ho·∫∑c ph·∫ßn m·ªÅm (vd: ki·ªÉm tra tr·∫°ng th√°i sau 50ms).

---->Nh·∫•n n√∫t MODE, x√°c nh·∫≠n LED chuy·ªÉn m√†u (vd: xanh ‚Üî v√†ng).


C. FUNCTIONAL REQUIREMENTS
1. System Initialization

-Initialize GPIO for sensors, pump, LED, buttons

-Set default configuration values

-Start in MODE_AUTO with pump OFF


2. Sensor Data Handling

-Periodically read sensors (using ADC)

-Apply moving average filter:
#define SAMPLE_SIZE 5
static float moisture_readings[SAMPLE_SIZE];

float filtered_moisture() {
    static uint8_t idx = 0;
    moisture_readings[idx] = HAL_ReadMoisture();
    idx = (idx + 1) % SAMPLE_SIZE;
    
    float sum = 0;
    for(uint8_t i=0; i<SAMPLE_SIZE; i++) {
        sum += moisture_readings[i];
    }
    return sum / SAMPLE_SIZE;
}

3. Automatic Watering Logic
void update_watering_logic(SystemState* state) {
    if(state->current_mode == MODE_AUTO) {
        if(state->sensor_readings.soil_moisture < state->config.moisture_min_th) {
            start_pumping(state);
        }
        else if(state->sensor_readings.soil_moisture > state->config.moisture_max_th ||
                (HAL_GetTick() - state->pump_start_time) > state->config.max_watering_time) { //?????
            stop_pumping(state);
        }
    }
}

4. Button Handling Logic
void handle_buttons(SystemState* state) {
    static uint32_t last_button1_time = 0;
    
    // Button 1: Mode toggle (with debouncing)
    if(HAL_Button1_Pressed() && (HAL_GetTick() - last_button1_time > 250)) {
        state->current_mode = (state->current_mode == MODE_AUTO) ? MODE_MANUAL : MODE_AUTO;
        last_button1_time = HAL_GetTick();
        
        if(state->current_mode == MODE_MANUAL) {
            stop_pumping(state);
        }
    }
    
    // Button 2: Manual watering
    if(state->current_mode == MODE_MANUAL && HAL_Button2_Pressed()) {
        start_pumping(state);
        state->pump_start_time = HAL_GetTick();
    }
}

5. LED State Management
void update_led_state(SystemState* state) {
    if(sensor_error()) {
        state->led_state = LED_ERROR;
    }
    else if(state->pump_state == PUMP_ON) {
        state->led_state = LED_WATERING;
    }
    else if(state->sensor_readings.soil_moisture < state->config.moisture_min_th) {
        state->led_state = LED_LOW_MOISTURE_ALERT;
        // Force to AUTO mode if moisture too low
        state->current_mode = MODE_AUTO;
    }
    else {
        state->led_state = LED_NORMAL;
    }
    
    // Update physical LED
    set_led_color(state->led_state);
}

D. MAIN OPERATION FLOW
int main(void) {
    SystemState sys_state;
    system_init(&sys_state);
    
    while(1) {
        // 1. Handle button presses
        handle_buttons(&sys_state);
        
        // 2. Read and process sensor data (periodically)
        if(HAL_GetTick() - sys_state.last_sensor_check > sys_state.config.check_interval) {
            read_sensors(&sys_state);
            sys_state.last_sensor_check = HAL_GetTick();
        }
        
        // 3. Execute watering logic
        update_watering_logic(&sys_state);
        
        // 4. Update status indicators
        update_led_state(&sys_state);
        report_system_status(&sys_state);
        
        // 5. Power management
        HAL_Delay(50);  // 50ms delay for power saving
    }
}

E. MEMORY OPTIMIZATION TECHNIQUES
1. Use enums instead of strings:
const char* get_state_name(LEDState state) {
    static const char* names[] = {
        [LED_NORMAL] = "NORMAL",
        [LED_WATERING] = "WATERING",
        [LED_LOW_MOISTURE_ALERT] = "LOW_MOISTURE",
        [LED_ERROR] = "ERROR"
    };
    return names[state];
}


2. Use bit-fields for compact storage:
typedef struct {
    uint8_t mode      : 1;  // 0: AUTO, 1: MANUAL
    uint8_t pump      : 1;  // 0: OFF, 1: ON
    uint8_t led_state : 2;  // 4 LED states
    uint8_t error     : 1;  // Error flag
} CompactState;


F. TESTING REQUIREMENTS
Simulator Tests (VSCode):
void test_auto_mode() {
    SystemState test_state = {0};
    test_state.current_mode = MODE_AUTO;
    test_state.sensor_readings.soil_moisture = 25.0f;  // Below threshold
    
    update_watering_logic(&test_state);
    assert(test_state.pump_state == PUMP_ON);
    
    test_state.sensor_readings.soil_moisture = 65.0f;  // Above threshold
    update_watering_logic(&test_state);
    assert(test_state.pump_state == PUMP_OFF);
}

void test_moisture_alert() {
    SystemState test_state = {0};
    test_state.current_mode = MODE_MANUAL;
    test_state.sensor_readings.soil_moisture = 20.0f;  // Very low
    
    update_led_state(&test_state);
    assert(test_state.led_state == LED_LOW_MOISTURE_ALERT);
    assert(test_state.current_mode == MODE_AUTO);  // Should force to AUTO
}

Hardware Tests (STM32):
-LED color changes match system state
-Pump activates when:
-Moisture < threshold (AUTO mode)
-Button pressed (MANUAL mode)
-Mode switching time < 100ms
-Power consumption < 5mA in idle

G. DIRECTORY STRUCTURE
Watering_System/
‚îú‚îÄ‚îÄ Core/
‚îÇ   ‚îú‚îÄ‚îÄ Inc/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ irrigation.h
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sensor_mgr.h
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Services/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ button_svc.h
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ led_service.h
‚îÇ   ‚îî‚îÄ‚îÄ Src/
‚îÇ       ‚îú‚îÄ‚îÄ App/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ irrigation.c
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ sensor_mgr.c
‚îÇ       ‚îî‚îÄ‚îÄ Services/
‚îÇ           ‚îú‚îÄ‚îÄ button_svc.c
‚îÇ           ‚îî‚îÄ‚îÄ led_service.c
‚îú‚îÄ‚îÄ Platforms/
‚îÇ   ‚îú‚îÄ‚îÄ Simulator_VSCode/
‚îÇ   ‚îî‚îÄ‚îÄ STM32F103C8T6/
‚îî‚îÄ‚îÄ Docs/
    ‚îî‚îÄ‚îÄ state_diagram.md

-This design ensures:
+Clear separation between hardware abstraction and business logic
+Efficient memory usage with optimized data structures
+Responsive button handling with debouncing
+Automatic fail-safe when moisture is critically low
+Consistent state management across modes
+Testable components for both simulation and hardware    
-------------------------------------------------------------
